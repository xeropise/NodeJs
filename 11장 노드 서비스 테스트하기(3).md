## 11.5 부하 테스트

- 이번 절에서는 다른 종류의 테스트를 진행해 보겠다. 바로 부하 테스트 (load test) 이다. 서버가 얼마만큼의 요청을 견딜 수 있는지 (또는 수용할 수 있는지) 테스트하는 방법이다.

- 내 코드가 실제로 배포되었을 때 어떤 문법적, 논리적 문제가 있을지는 유닛 테스트와 통합 테스트를 통해 어느 정도 확인할 수 있었다. 그러나 내 서버가 몇 명의 동시 접속자나 일일 사용자를 수용할 수 있는지 예측하는 일은 매우 어렵다. 특히 실제 서비스 중이 아니라 개발 중일 때는 예측하는 것이 더 어려워진다.

- 코드에 문법적, 논리적 문제가 없더라도 서버의 하드웨어 제약 때문에 서비스가 중단될 수 있다. 대표적인 것인 OOM (Out Of Memotry) 문제이다. 서버는 접속자들의 정보를 저장하기 위해 각각의 접속자마다 일정한 메모리르 할당한다. 이렇게 사용하는 메모리의 양이 증가하다가 서버의 메모리 용량이 넘어서게 되면 문제가 발생한다. 부하 테스트를 통해 이를 어느 정도 예측 할 수 있다.

- artillery 를 설치하고 서버를 실행하자.

```
$ npm i -D artillery
$ npm start
```

- 새로운 콘솔을 하나 더 띄운후 다음 명령어를 입력하자.

```
$ npx artillery quick --count 100 -n 50 http://localhost:8001
```

- http://localhost:8001 에 빠르게 부하 테스트를 하는 방법이다. --count 옵션은 가상의 사용자 수를 의미하고, -n 옵션은 요청 횟수를 의마한다. 100 명의 가상 사용자가 50번씩 요청을 보내므로 총 5,000 번의 요청이 서버로 전달 된다. 5,000 번은 사실 그렇게 많은 요청은 아니지만, 절대적인 숫자가 중요한 것이 아니라, 하나의 요청이 얼마나 많은 작업을 하는지가 더 중요하다.

> 실제 서비스를 부하 테스트할 때

```
실제 서비스에 부하 테스트를 하기 보다는 실제 서버와 같은 사양의 서버 (보통 stg 서버) 를 만든 후, 그 서버에 부하 테스트를 진행하는 것이 좋다. AWS 나 GCP 같은 클라우드에서 종량제 요금을 선택한 경우 과다한 요금이 청구될 수 있다.
```

- 부하 테스트를 할 떄 단순히 한 페이지에만 요청을 보내는 것이 아니라 실제 사용자의 행동을 모방하여 시나리오를 작성할 수 있다. 이땐 JSON 형식의 설정 파일을 작성해야 한다.

_loadtest.json_

```json
{
  "config": {
    "target": "http://localhost:8001",
    "phases": [
      {
        "duration": 60,
        "arrivalRate": 30
      }
    ]
  },
  "scenarios": [
    {
      "flow": [
        {
          "get": {
            "url": "/"
          }
        },
        {
          "post": {
            "url": "/auth/login",
            "json": {
              "email": "zerohch0@naver.com",
              "password": "nodejsbook"
            }
          }
        },
        {
          "get": {
            "url": "/hashtag?hashtag=nodebird"
          }
        }
      ]
    }
  ]
}
```

- config 객체에 target 을 현재 서버로 잡고, phases 에서 60초 동안 (duration), 매초 30명의 사용자 (arrivalRate) 를 생성하도록 했다. 즉, 1800 명이 접속하는 상황이다.

- 이제 이 가상사용자들이 어떠한 동작을 할지 scenarios 속성에 적는다. 첫 번쨰 flow 로는 먼저 메인 페이지(GET /)에 접속하고, 로그인(POST /auth/login)을 한 후 해시태그 검색(GET /hashtag?hashtag=nodebird) 를 한다. 로그인할 떄 요청의 본문으로 email 과 password 를 JSON 형식으로 보낸다.

- 아직 flow 가 하나뿐이지만, 첫 번쨰 flow 와는 다른 일련의 과정을 시뮬레이션을 하고 싶다면 두 번쨰 flow 로 만들면 된다.

- npx artillery run 파일명 명렁어로 부하 테스트를 실행하자. 1800 명의 접속자가 각각 네 번의 요청을 보내서 (한 번의 redirect 포함) 총 7,200 번의 요청이 전송된다. 각각의 요청이 모두 데이터베이스에 최소 한 번씩 접근하므로 상당히 무리가 간다.

- 일반적으로 요청-응답 시 데이터베이스에 접근할 떄 가장 많은 시간이 소요된다. 서버는 여러 대로 늘리기 쉽지만, 데이터베이스는 늘리기 어려우므로 하나의 데이터베이스에 많은 요청이 몰리곤 한다. 따라서 최대한 데이터베이스에 접근하는 요청을 줄이면 좋다. 반복적으로 가져오는 데이터는 캐싱을 한다든지 하여, 데이터베이스에 접근하는 일을 줄이도록 하자.

---

## 11.6 프로젝트 마무리하기

- 코드를 테스트 할 때 어느 범위까지 테스트해야 하는지 고민될 수 있다. 보통 자신의 코드는 최대한 많이 테스트하는 것이 좋지만, npm 을 통해 설치한 패키지나 다른 사람의 라이브러리 자체는 테스트하지 않는다. 그 패키지나 라이브러리를 테스트 하는 것은 그들의 몫이다. 우린 우리 프로그램에서 그 패키지나 라이브러리를 사용하는 부분을 테스트하면 된다.

- 테스트하기 어려운 패키지는 모킹하고, 테스트할 수 있는 패키지는 그대로 테스트한다. 단, 모킹할 떄는 실제 상황에서는 에러가 발생할 수 있음을 염두에 두어야 한다.

- NodeBird 서비스느 ㄴ여기서 마치고, 다음 장에서는 웹 소켓과 서버센트 이벤트 (Server Sent Events, SSE) 를 사용하여 실시간 애플리케이션을 제작해보겠다.

### 11.6.1 서비스 해보기

- 모든 함수에 대한 유닛 테스트 작성하기 (테스트 커버리지 100% 도전하기)

- 모든 라우터에 대한 통합 테스트 작성하기

- 부하 테스트를 통해 병목점 및 개선점 찾기

### 11.6.2 핵심 정리

- 테스트를 작성한다고 해서 에러가 발생하지 않는 것은 아니다. 하지만 자신의 코드에 대한 믿음을 가질 수는 있다.

- 테스트를 올바르게 작성하지 않으면 테스트를 하지 않는 것보다 못한 상황이 발생한다.

- 테스트를 작성하면 나중에 코드 변경 사항이 생겼을 때 어떤 부분에 영향을 미치는지 쉽게 파악할 수 있다. 이러한 긍정적인 영향과 테스트하는 데 필요한 공수를 함께 고려해서 테스트할 범위를 정해야 한다.

- 실제 서비스에서는 모든 기능을 테스트하기 어려우므로 우선순위를 정하여 우선순위가 높은 기능 위주로 테스트하자.

- 테스트 커버리지가 100% 라고 해서 에러가 발생하지 않는 것은 아니다.
