## 10.4 다른 서비스에서 호출하기

- API 제공 서버를 만들었으니, API 를 사용하는 서비스도 만들어 보자. 이 서비스는 다른 서버에게 요청을 보내므로 클라이언트 역할을 한다.

- API 제공자가 아닌 API 사용자의 입장에서 진행하는 것이며, 바로 NodeBird 앱의 데이터를 가져오고 싶어 하는 사용자이다.

- 보통 그 데이터를 가공해 2차적인 서비스를 하려는 회사가 API 를 이용하곤 한다. 예를 들어 쇼핑몰들이 있으면, 쇼핑몰들의 최저가를 알려주는 서비스가 2차 서비스가 된다. 2차 서비스 이름은 NodeCat 이다.

- nodebird-api 폴더와 같은 위치에 nodecat 이라는 새로운 폴더를 만들자. 별도의 서버이므로 nodebird-api 와 코드가 섞이지 않게 주의하자

_nodecat/package.json_

```json
{
  "name": "nodecat",
  "version": "0.0.1",
  "description": "노드버스 2차 서비스",
  "main": "app.js",
  "dependencies": {
    "axios": "^0.21.1",
    "cookie-parser": "^1.4.5",
    "dotenv": "^8.2.0",
    "express": "^4.17.1",
    "express-session": "^1.17.1",
    "morgan": "^1.10.0",
    "nunjucks": "^3.2.3"
  },
  "devDependencies": {
    "nodemon": "^2.0.7"
  },
  "scripts": {
    "start": "nodemon app"
  },
  "author": "xeropise",
  "license": "ISC"
}
```

```
$ npm i
```

- 이 서버의 주 목적은 nodebird-api 의 API 를 통해 데이터를 가져오는 것이다. 가져온 데이터는 JSON 형태이므로 퍼그나 넌적스 같은 템플릿 엔진으로 데이터를 렌더링할 수도 있다. 서버 파일과 에러를 표시할 파일을 생성하자.

_nodecat/app.js_

```javascript
const express = require("express");
const morgan = require("morgan");
const cookieParser = require("cookie-parser");
const session = require("express-session");
const nunjucks = require("nunjucks");
const dotenv = require("dotenv");

dotenv.config();
const indexRouter = require("./routes");

const app = express();
app.set("port", process.env.PORT || 4000);
app.set("view engine", "html");
nunjucks.configure("views", {
  express: app,
  watch: true,
});

app.use(morgan("dev")); // logger
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(
  session({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SECRET,
    cookie: {
      httpOnly: true,
      secure: false,
    },
  })
);

app.use("/", indexRouter);

// 404 에러 처리 미들웨어
app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

// 에러 처리 미들웨어
app.use((err, req, res, next) => {
  res.locals.message = err.message;
  res.locals.error = process.env.NODE_ENV !== "production" ? err : {};
  res.status(err.status || 500);
  res.render("error");
});

app.listen(app.get("port"), () => {
  console.log(app.get("port"), "번 포트에서 대기 중");
});
```

- 사용하지 않는 미들웨어는 걷어내고 최소한으로 app.js 를 구성했다.

_nodecat/views/error.html_

```html
<h1>{{message}}</h1>
<h2>{{error.status}}</h2>
<pre>{{error.stack}}</pre>
```

- API를 사용하려면 먼저 사용자 인증을 받아야 하므로 사용자 인증이 원활하게 진행되는지 테스트 하는 라우터를 만들어 보자.

- 조금 전에 발급받은 clientSecret 을 .env 에 넣자.
