# 12장 웹 소켓으로 실시간 데이터 전송하기

이 장에선 웹 소켓을 사용하여 실시간으로 데이터를 주고받는 방법을 배워보자. 실시간으로 데이터를 전달할 수 있으면 만들 수 있는 앱의 폭이 넓어진다. 웹 소켓의 개념을 먼저 익히고 웹 소켓을 사용하여 GIF 채팅방을 만들어 보자.

---

## 12.1 웹 소켓 이해하기

- 노드 생태계에서는 웹 소켓이란 말을 들으면 Socket.IO 를 먼저 떠올리는 경우가 많다. 하지만 Socket.IO 는 웹 소켓을 활용한 라이브러리일 뿐이며 웹 소켓 그 자체는 아니다. 나중에 Socket.IO 를 사용하기 위해서는 기반 기술인 웹 소켓에 대해 먼저 알아야 한다.

![1](https://user-images.githubusercontent.com/50399804/113309937-a331b300-9342-11eb-8982-bdbc11591fb1.JPG)

- 웹 소켓은 HTML5 에 새로 추가된 스펙으로 실시간 양방향 데이터 전송을 위한 기술이며, HTTP 와 다르게 WS 라는 프로토콜을 사용한다. 따라서 브라우저와 서버가 WS 프로토콜을 지원하면 사용할 수 있다.

- 최신 브라우저는 대부분 웹 소켓을 지원하고, 노드에서는 ws 나 Socket.IO 같은 패키지를 통해 웹 소켓을 사용할 수 있다.

- 웹 소켓이 나오기 이전에는 HTTP 기술을 사용하여 실시간 데이터 전송을 구현했다. 그중 한 가지가 폴링(polling) 이라고 불리는 방식이다. HTTP 클라이언트에서 서버로 향하는 단방향 통신이므로 주기적으로 서버에 새로운 업데이트가 있는지 확인하는 요청을 보낸 후, 있다면 새로운 내용을 가져오는 단순 무식한 방법이었다.

- 그러다가 HTML5 가 나오면서 웹 브라우저와 웹 서버가 지속적으로 연결된 라인을 통해 실시간으로 데이터를 주고받을 수 있는 웹 소켓이 등장했다. 처음에 웹 소켓 연결이 이루어지고 나면 그 다음부터는 계속 연결된 상태로 있으므로 따로 업데이트가 있는지 요청을 보낼 필요가 없다.

- 업데이트할 내용이 생겼다면 서버에서 바로 클라이언트에 알린다. HTTP 프로토콜과 포트를 공유할 수 있으므로 다른 포트에 연결할 필요도 없다. 폴링 방식에 비해 성능도 매우 개선되었다.

- 참고로 **서버센트 이벤트** (Server Sent Events) 이하 SSE 라는 기술도 등장했다. EventSource 라는 객체를 사용하는데, 처음에 한 번만 연결하면 서버가 클라이언트에 지속적으로 데이터를 보낸다.

- 웹 소켓과 다른 점은 클라이언트에서 서버로는 데이터를 보낼 수 없다는 것이다. 즉, 서버에서 클라이언트로 데이터를 보내는 단방향 통신이다. 따라서 웹 소켓만이 진정한 양방향 통신이다.

- 양방향 통신이므로 SSE 에서 할 수 있는 것은 웹 소켓으로 모두 할 수 있다. 하지만 주식 차트 업데이트나 SNS 에서 새로운 게시물 가져오기 등 굳이 양방향 통신이 필요 없는 경우도 많다.

- 서버에서 일방적으로 데이터를 내려주기만 하면 되기 때문이다. 다음 장에서 경매 시스템을 만들 때 SSE 기술을 사용해 보자.

![2](https://user-images.githubusercontent.com/50399804/113309934-a2991c80-9342-11eb-833c-8c97fe288c9b.JPG)

- Socket.IO 는 웹 소켓을 편리하게 사용할 수 있도록 도와주는 라이브러리이다. Socket.IO 는 웹 소켓을 지원하지 않는 IE9 와 같은 브라우저에서는 알아서 웹 소켓 대신 폴링 방식을 사용하여 실시간 데이터 전송을 가능하게 한다.

- 클라이언트 측에서 웹 소켓이 연결이 끊꼈다면 자동으로 재 연결을 시도하고, 채팅방을 쉽게 구현할 수 있도록 메서드를 준비해두었다.

- Socket.IO 를 사용하기 전에 ws 모듈로 웹 소켓이 무엇인지 직접 체험해 보자.

---

## 12.2 ws 모듈로 웹 소켓 사용하기

- 먼저 gif-chat 이라는 새로운 프로젝트를 만들자.

_package.json_

```json
{
  "name": "gif-chat",
  "version": "0.0.1",
  "description": "GIF 웹소켓 채팅방",
  "main": "app.js",
  "scripts": {
    "test": "nodemon app"
  },
  "author": "xeropise",
  "license": "ISC",
  "dependencies": {
    "cookie-parser": "^1.4.5",
    "dotenv": "^8.2.0",
    "express": "^4.17.1",
    "express-session": "^1.17.1",
    "morgan": "^1.10.0",
    "nunjucks": "^3.2.3"
  },
  "devDependencies": {
    "nodemon": "^2.0.7"
  }
}
```

_.env_

```
COOKIE_SECRET=gifchat
```

_app.js_

```javascript
const express = require("express");
const path = require("path");
const morgan = require("morgan");
const cookieParser = require("cookie-parser");
const session = require("express-session");
const nunjucks = require("nunjucks");
const dotenv = require("dotenv");

dotenv.config();
const indexRouter = require("./routes");

const app = express();
app.set("port", process.env.PORT || 8005);
app.set("view engine", "html");

nunjucks.configure("views", {
  express: app,
  watch: true,
});

app.use(morgan("dev"));
app.use(express.static(path.join(__dirname, "public")));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(
  session({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SECRET,
    cookie: {
      httpOnly: true,
      secure: false,
    },
  })
);

app.use("/", indexRouter);

app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  res.locals.message = err.message;
  res.locals.error = process.env.NODE_ENV !== "production" ? err : {};
  res.status(err.status || 500);
  res.render("error");
});

app.listen(app.get("port"), () => {
  console.log(app.get("port"), "번 포트에서 대기 중");
});
```

_routes/index.js_

```javascript
const express = require("express");

const router = express.Router();

router.get("/", (req, res) => {
  res.render("index");
});

module.exports = router;
```

- 이제 ws 모듈을 설치하여 노드에 웹 소켓을 구현해 보자.

```
$ npm i ws
```

- 웹 소켓을 익스프레스 서버에 연결하자. socket.js 는 조금 뒤에 만든다.

_app.js_

```javascript
const express = require("express");
const path = require("path");
const morgan = require("morgan");
const cookieParser = require("cookie-parser");
const session = require("express-session");
const nunjucks = require("nunjucks");
const dotenv = require("dotenv");

dotenv.config();
const webSocket = require("./socket");
const indexRouter = require("./routes");

(...)

const server = app.listen(app.get("port"), () => {
  console.log(app.get("port"), "번 포트에서 대기 중");
});

webSocket(server);
```

- 이제 웹 소켓 로직이 들어 있는 socket.js 파일을 작성해 보자.

_socket.js_

```javascript
const WebSocket = require("ws");

module.exports = (server) => {
  const wss = new WebSocket.Server({ server });

  wss.on("connection", (ws, req) => {
    // 웹 소켓 연결 시
    const ip = req.headers["x-forwarded-for"] || req.connection.remoteAddress;
    console.log("새로운 클라이언트 접속", ip);
    ws.on("message", (message) => {
      // 클라이언트로부터 메시지 수신 시
      console.log(message);
    });
    ws.on("error", (error) => {
      // 에러 시
      console.error(error);
    });
    ws.on("close", () => {
      // 연결 종료 시
      console.log("클라이언트 접속 해제", ip);
      clearInterval(ws.interval);
    });

    ws.interval = setInterval(() => {
      // 3초마다 클라이언트로 메시지 전송
      if (ws.readyState === ws.OPEN) {
        ws.send("서버에서 클라이언트로 메시지를 보냅니다.");
      }
    }, 3000);
  });
};
```
